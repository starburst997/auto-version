name: "Auto Version Tagger"
description: "Automatically determine and tag semantic versions based on git tags"
author: "starburst997"

branding:
  icon: "tag"
  color: "blue"

inputs:
  token:
    description: "GitHub token for API operations"
    required: false
    default: "${{ github.token }}"
  main-branch:
    description: "Name of the main/production branch"
    required: false
    default: "main"
  dev-branch:
    description: "Name of the development branch"
    required: false
    default: "dev"
  default-version:
    description: "Default version if no tags exist"
    required: false
    default: "1.0.0"
  git-config:
    description: "Set git config"
    required: false
    default: "true"
  git-user-name:
    description: "Git user name for tagging"
    required: false
    default: "github-actions[bot]"
  git-user-email:
    description: "Git user email for tagging"
    required: false
    default: "github-actions[bot]@users.noreply.github.com"
  update-major-minor:
    description: "Update major and minor version tags (e.g., v1, v1.2) to point to latest version"
    required: false
    default: "false"
  yearly:
    description: "Use year as major version (e.g., 2025.0.0) and auto-update on new year"
    required: false
    default: "false"
  git-push:
    description: "Push changes and tags to remote repository"
    required: false
    default: "true"
  no-tags:
    description: "Skip tag creation and pushing (only calculate version)"
    required: false
    default: "false"
  edit-file:
    description: "File to update with new version (e.g., action.yml). If empty, file editing is skipped"
    required: false
    default: ""
  edit-search-pattern:
    description: "Search pattern for version replacement (default uses repository name)"
    required: false
    default: "${{ github.repository }}:"
  edit-commit-message:
    description: "Commit message template for file edit (use {version} placeholder)"
    required: false
    default: "chore: update version to {version}"
  update-version-files:
    description: "Automatically update version in common version files (package.json, pyproject.toml, etc.) without committing"
    required: false
    default: "true"

outputs:
  version:
    description: "Calculated version (e.g., 1.2.3 or 1.2.3-dev)"
    value: ${{ steps.calculate.outputs.version }}
  tag:
    description: "Git tag (e.g., v1.2.3 or v1.2.3-dev)"
    value: ${{ steps.calculate.outputs.tag }}
  environment:
    description: "Environment type (production, dev, rc, or pr-###)"
    value: ${{ steps.calculate.outputs.environment }}

runs:
  using: "composite"
  steps:
    - name: Configure Git
      if: inputs.git-config == 'true'
      shell: bash
      run: |
        # Only set git config if not already configured
        if [ -z "$(git config user.name)" ]; then
          git config user.name "${{ inputs.git-user-name }}"
          echo "‚úÖ Set git user.name to ${{ inputs.git-user-name }}"
        else
          echo "‚ÑπÔ∏è  Git user.name already set to: $(git config user.name)"
        fi

        if [ -z "$(git config user.email)" ]; then
          git config user.email "${{ inputs.git-user-email }}"
          echo "‚úÖ Set git user.email to ${{ inputs.git-user-email }}"
        else
          echo "‚ÑπÔ∏è  Git user.email already set to: $(git config user.email)"
        fi

    - name: Calculate Version
      id: calculate
      shell: bash
      run: |
        set -eo pipefail  # Exit on error and pipe failures

        # Fetch all tags
        git fetch --tags || true

        MAIN_BRANCH="${{ inputs.main-branch }}"
        DEV_BRANCH="${{ inputs.dev-branch }}"
        DEFAULT_VERSION="${{ inputs.default-version }}"
        YEARLY_MODE="${{ inputs.yearly }}"

        # Get current year if yearly mode is enabled
        if [ "$YEARLY_MODE" == "true" ]; then
          CURRENT_YEAR=$(date +%Y)
          DEFAULT_VERSION="${CURRENT_YEAR}.0.0"
        fi

        # Helper function to handle yearly mode logic when incrementing minor
        # If yearly mode is enabled and current year > major, update major to current year
        handle_yearly_minor_increment() {
          local major=$1
          local minor=$2

          if [ "$YEARLY_MODE" == "true" ]; then
            if [ "$CURRENT_YEAR" -gt "$major" ]; then
              echo "$CURRENT_YEAR 0"
            else
              echo "$major $((minor + 1))"
            fi
          else
            echo "$major $((minor + 1))"
          fi
        }

        # Function to check commit messages for version bump commands
        check_commit_messages_for_bump() {
          local last_tag=$1
          local bump_type="patch"  # default

          # Get all commits since last tag (or all commits if no tag)
          local commits
          if [ -n "$last_tag" ]; then
            commits=$(git log "${last_tag}..HEAD" --format="%s %b" 2>/dev/null || true)
          else
            commits=$(git log --format="%s %b" 2>/dev/null || true)
          fi

          # Check for /major or /minor in commit messages
          if echo "$commits" | grep -q "/major"; then
            if [ "$YEARLY_MODE" == "true" ]; then
              echo "‚ö†Ô∏è  /major command found but ignored in yearly mode (year is controlled automatically)"
              bump_type="minor"  # Treat as minor in yearly mode
            else
              bump_type="major"
            fi
          elif echo "$commits" | grep -q "/minor"; then
            bump_type="minor"
          fi

          echo "$bump_type"
        }

        # Detect context: PR or push, and which branch
        IS_PR="${{ github.event_name == 'pull_request' }}"
        if [ "$IS_PR" == "true" ]; then
          BASE_REF="${{ github.base_ref }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
        else
          CURRENT_BRANCH="${{ github.ref_name }}"
        fi

        # Determine release type based on context
        if [ "$IS_PR" == "true" ]; then
          if [ "$BASE_REF" == "$MAIN_BRANCH" ]; then
            RELEASE_TYPE="rc"
          else
            RELEASE_TYPE="pr"
          fi
        else
          if [ "$CURRENT_BRANCH" == "$MAIN_BRANCH" ]; then
            RELEASE_TYPE="production"
          elif [ "$CURRENT_BRANCH" == "$DEV_BRANCH" ]; then
            RELEASE_TYPE="dev"
          else
            echo "‚ùå Unsupported branch: $CURRENT_BRANCH"
            exit 1
          fi
        fi

        echo "üîç Detected context: $RELEASE_TYPE"

        case "$RELEASE_TYPE" in
          production)
            # Get latest stable production tag
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)

            # Check for version bump commands in commits
            BUMP_TYPE=$(check_commit_messages_for_bump "$LATEST_STABLE")
            echo "üîç Detected bump type from commits: $BUMP_TYPE"

            # Get latest dev or rc tag to determine production version
            LATEST_DEV_TAG=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)
            LATEST_RC_TAG=$(git tag -l "v*-rc.*" --sort=-version:refname | head -n1 || true)

            # Determine base version from dev/rc tags
            if [ -z "$LATEST_DEV_TAG" ] && [ -z "$LATEST_RC_TAG" ]; then
              # No dev/rc tags exist (direct commits to main)
              if [ -z "$LATEST_STABLE" ]; then
                # No tags at all, use default
                VERSION="$DEFAULT_VERSION"
              else
                # Only stable tags exist (direct main commits)
                STABLE_VER=${LATEST_STABLE#v}
                IFS='.' read -r MAJOR MINOR PATCH <<< "$STABLE_VER"

                # Apply bump type from commit messages
                case "$BUMP_TYPE" in
                  major)
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                    ;;
                  minor)
                    read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                    PATCH=0
                    ;;
                  patch)
                    PATCH=$((PATCH + 1))
                    ;;
                esac

                VERSION="${MAJOR}.${MINOR}.${PATCH}"
              fi
            else
              # Use latest dev or rc tag
              if [ -n "$LATEST_RC_TAG" ]; then
                LATEST_TAG=$LATEST_RC_TAG
              else
                LATEST_TAG=$LATEST_DEV_TAG
              fi

              # Strip 'v' and suffix to get base version
              BASE_VERSION=${LATEST_TAG#v}
              BASE_VERSION=${BASE_VERSION%%-*}

              # Check if this version already exists as stable
              if git rev-parse "v${BASE_VERSION}" >/dev/null 2>&1; then
                # Version already exists, increment minor (hotfix scenario)
                IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
                read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                VERSION="${MAJOR}.${MINOR}.0"
                echo "‚ö†Ô∏è  Version ${BASE_VERSION} already exists, using ${VERSION} (hotfix)"
              else
                # Version doesn't exist, use it
                VERSION="$BASE_VERSION"
              fi
            fi
            ;;

          dev)
            # Get latest stable (production) tag
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)

            # Get latest dev tag
            LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

            # Check for version bump commands in commits
            BUMP_TYPE=$(check_commit_messages_for_bump "$LATEST_DEV")
            echo "üîç Detected bump type from commits: $BUMP_TYPE"

            if [ -z "$LATEST_STABLE" ] && [ -z "$LATEST_DEV" ]; then
              # No tags exist, use default
              IFS='.' read -r MAJOR MINOR PATCH <<< "$DEFAULT_VERSION"
            elif [ -n "$LATEST_STABLE" ] && [ -z "$LATEST_DEV" ]; then
              # Production release exists but no dev yet, bump minor
              VERSION=${LATEST_STABLE#v}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
              read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
              PATCH=0
            elif [ -n "$LATEST_STABLE" ]; then
              # Compare versions - if stable >= dev, we just released to prod
              STABLE_VER=${LATEST_STABLE#v}
              DEV_VER=${LATEST_DEV#v}
              DEV_VER=${DEV_VER%%-*}

              # Use sort -V to compare versions
              NEWER=$(printf "%s\n%s" "$STABLE_VER" "$DEV_VER" | sort -V -r | head -n1)

              if [ "$NEWER" == "$STABLE_VER" ]; then
                # Production is newer or equal, bump minor from stable
                IFS='.' read -r MAJOR MINOR PATCH <<< "$STABLE_VER"
                read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                PATCH=0
              else
                # Continue from dev
                IFS='.' read -r MAJOR MINOR PATCH <<< "$DEV_VER"

                # Apply bump type from commit messages
                case "$BUMP_TYPE" in
                  major)
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                    ;;
                  minor)
                    read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                    PATCH=0
                    ;;
                  patch)
                    PATCH=$((PATCH + 1))
                    ;;
                esac
              fi
            else
              # Only dev tags exist
              VERSION=${LATEST_DEV#v}
              VERSION=${VERSION%%-*}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

              # Apply bump type from commit messages
              case "$BUMP_TYPE" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
            fi

            VERSION="${MAJOR}.${MINOR}.${PATCH}-dev"
            ;;

          rc)
            # Get latest dev or stable version tag to base our version on
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)
            LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

            # Use the most recent version as base
            if [ -n "$LATEST_DEV" ]; then
              LATEST_TAG=$LATEST_DEV
            elif [ -n "$LATEST_STABLE" ]; then
              LATEST_TAG=$LATEST_STABLE
            else
              LATEST_TAG=""
            fi

            if [ -z "$LATEST_TAG" ]; then
              MAJOR=1
              MINOR=0
              PATCH=0
            else
              VERSION_STR=${LATEST_TAG#v}
              VERSION_STR=${VERSION_STR%%-*}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_STR"
            fi

            BASE_VERSION="${MAJOR}.${MINOR}.${PATCH}"

            # Count existing rc tags for this base version
            RC_COUNT=$(git tag -l "v${BASE_VERSION}-rc.*" 2>/dev/null | wc -l | tr -d ' ')
            RC_NUM=$((RC_COUNT + 1))

            VERSION="${BASE_VERSION}-rc.${RC_NUM}"
            ;;

          pr)
            # Get latest dev or stable version tag to base our version on
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)
            LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

            # Use the most recent version as base
            if [ -n "$LATEST_DEV" ]; then
              LATEST_TAG=$LATEST_DEV
            elif [ -n "$LATEST_STABLE" ]; then
              LATEST_TAG=$LATEST_STABLE
            else
              LATEST_TAG=""
            fi

            if [ -z "$LATEST_TAG" ]; then
              MAJOR=1
              MINOR=0
              PATCH=0
            else
              VERSION_STR=${LATEST_TAG#v}
              VERSION_STR=${VERSION_STR%%-*}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_STR"
            fi

            BASE_VERSION="${MAJOR}.${MINOR}.${PATCH}"

            # Count existing pr tags for this PR number and base version
            PR_COUNT=$(git tag -l "v${BASE_VERSION}-pr-${PR_NUMBER}.*" 2>/dev/null | wc -l | tr -d ' ')
            PR_NUM=$((PR_COUNT + 1))

            VERSION="${BASE_VERSION}-pr-${PR_NUMBER}.${PR_NUM}"
            ;;

          *)
            echo "‚ùå Invalid release-type: $RELEASE_TYPE"
            exit 1
            ;;
        esac

        # Determine environment output
        case "$RELEASE_TYPE" in
          production)
            ENVIRONMENT="production"
            ;;
          dev)
            ENVIRONMENT="dev"
            ;;
          rc)
            ENVIRONMENT="rc"
            ;;
          pr)
            ENVIRONMENT="pr-${PR_NUMBER}"
            ;;
        esac

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$VERSION" >> $GITHUB_OUTPUT
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "üì¶ Version: $VERSION"
        echo "üåç Environment: $ENVIRONMENT"

    - name: Update File with New Version
      if: inputs.edit-file != ''
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        EDIT_FILE="${{ inputs.edit-file }}"
        SEARCH_PATTERN="${{ inputs.edit-search-pattern }}"
        VERSION="${{ steps.calculate.outputs.tag }}"
        COMMIT_MESSAGE="${{ inputs.edit-commit-message }}"

        echo "üìù Updating $EDIT_FILE with version $VERSION"

        # Convert repository name to lowercase for registry compatibility
        REPO_NAME=$(echo "$SEARCH_PATTERN" | tr '[:upper:]' '[:lower:]')

        # Replace version in file using sed
        sed -i "s|${REPO_NAME}[^\"]*|${REPO_NAME}${VERSION}|g" "$EDIT_FILE"

        # Check if file was actually changed
        if git diff --quiet "$EDIT_FILE"; then
          echo "‚ÑπÔ∏è  No changes to $EDIT_FILE"
          exit 0
        fi

        # Replace {version} placeholder in commit message
        FINAL_MESSAGE="${COMMIT_MESSAGE/\{version\}/$VERSION}"

        # Get the current commit SHA
        BASE_SHA=$(git rev-parse HEAD)

        # Read the updated file content
        FILE_CONTENT=$(base64 -w 0 "$EDIT_FILE")

        # Get the file SHA (needed for update)
        FILE_SHA=$(gh api "repos/${{ github.repository }}/contents/$EDIT_FILE" --jq .sha)

        # Create commit via GitHub API
        gh api "repos/${{ github.repository }}/contents/$EDIT_FILE" \
          --method PUT \
          --field message="$FINAL_MESSAGE" \
          --field content="$FILE_CONTENT" \
          --field sha="$FILE_SHA" \
          --field branch="${{ github.ref_name }}"

        # Get latest changes
        git checkout "$EDIT_FILE"
        git pull

        echo "‚úÖ Updated $EDIT_FILE via GitHub API with verified commit"

    - name: Update Version Files
      if: inputs.update-version-files == 'true'
      shell: bash
      run: |
        VERSION="${{ steps.calculate.outputs.version }}"

        echo "üìù Updating version files with version $VERSION"

        # JavaScript/TypeScript - package.json
        if [ -f "package.json" ]; then
          echo "  Updating package.json"
          sed -i "s/\"version\": *\"[^\"]*\"/\"version\": \"$VERSION\"/g" package.json
        fi

        # Python - pyproject.toml
        if [ -f "pyproject.toml" ]; then
          echo "  Updating pyproject.toml"
          sed -i "s/^version *= *\"[^\"]*\"/version = \"$VERSION\"/g" pyproject.toml
        fi

        # Python - setup.py
        if [ -f "setup.py" ]; then
          echo "  Updating setup.py"
          sed -i "s/version=['\"][^'\"]*['\"]/version='$VERSION'/g" setup.py
        fi

        # Rust - Cargo.toml
        if [ -f "Cargo.toml" ]; then
          echo "  Updating Cargo.toml"
          sed -i "s/^version *= *\"[^\"]*\"/version = \"$VERSION\"/g" Cargo.toml
        fi

        # Go - VERSION file (common pattern)
        if [ -f "VERSION" ]; then
          echo "  Updating VERSION"
          echo "$VERSION" > VERSION
        fi

        # Ruby - gemspec files
        if ls *.gemspec 1> /dev/null 2>&1; then
          for file in *.gemspec; do
            echo "  Updating $file"
            sed -i "s/\.version *= *['\"][^'\"]*['\"]/\.version = '$VERSION'/g" "$file"
          done
        fi

        # PHP - composer.json
        if [ -f "composer.json" ]; then
          echo "  Updating composer.json"
          sed -i "s/\"version\": *\"[^\"]*\"/\"version\": \"$VERSION\"/g" composer.json
        fi

        # .NET - *.csproj files
        if ls *.csproj 1> /dev/null 2>&1; then
          for file in *.csproj; do
            echo "  Updating $file"
            sed -i "s|<Version>[^<]*</Version>|<Version>$VERSION</Version>|g" "$file"
            sed -i "s|<AssemblyVersion>[^<]*</AssemblyVersion>|<AssemblyVersion>$VERSION</AssemblyVersion>|g" "$file"
            sed -i "s|<FileVersion>[^<]*</FileVersion>|<FileVersion>$VERSION</FileVersion>|g" "$file"
          done
        fi

        # Gradle - gradle.properties
        if [ -f "gradle.properties" ]; then
          echo "  Updating gradle.properties"
          sed -i "s/^version *= *[^ ]*/version=$VERSION/g" gradle.properties
        fi

        # Maven - pom.xml (first occurrence only, to avoid changing dependency versions)
        if [ -f "pom.xml" ]; then
          echo "  Updating pom.xml"
          sed -i "0,/<version>[^<]*<\/version>/s|<version>[^<]*</version>|<version>$VERSION</version>|" pom.xml
        fi

        echo "‚úÖ Version files updated (not committed)"

    - name: Create Tags
      if: inputs.no-tags == 'false'
      shell: bash
      run: |
        git tag ${{ steps.calculate.outputs.tag }}
        echo "‚úÖ Created tag ${{ steps.calculate.outputs.tag }}"

    - name: Update Major/Minor Tags
      if: inputs.update-major-minor == 'true' && inputs.no-tags == 'false'
      shell: bash
      run: |
        VERSION=${{ steps.calculate.outputs.version }}

        # Detect release type from version suffix
        if [[ "$VERSION" == *"-dev"* ]]; then
          RELEASE_TYPE="dev"
        elif [[ "$VERSION" == *"-rc."* ]]; then
          RELEASE_TYPE="rc"
        elif [[ "$VERSION" == *"-pr-"* ]]; then
          RELEASE_TYPE="pr"
        else
          RELEASE_TYPE="production"
        fi

        # Strip any pre-release suffix (e.g., -dev, -rc.1, -pr-123.1)
        BASE_VERSION=${VERSION%%-*}

        # Extract major and minor versions
        IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

        case "$RELEASE_TYPE" in
          production)
            # Update major version tag (e.g., v1)
            git tag -f "v${MAJOR}"

            # Update minor version tag (e.g., v1.2)
            git tag -f "v${MAJOR}.${MINOR}"

            echo "‚úÖ Created tags: v${MAJOR} and v${MAJOR}.${MINOR}"
            ;;

          dev)
            # Update dev major version tag (e.g., v1-dev)
            git tag -f "v${MAJOR}-dev"

            # Update dev minor version tag (e.g., v1.2-dev)
            git tag -f "v${MAJOR}.${MINOR}-dev"

            echo "‚úÖ Created tags: v${MAJOR}-dev and v${MAJOR}.${MINOR}-dev"
            ;;

          rc)
            # Update rc major version tag (e.g., v1-rc)
            git tag -f "v${MAJOR}-rc"

            # Update rc minor version tag (e.g., v1.2-rc)
            git tag -f "v${MAJOR}.${MINOR}-rc"

            echo "‚úÖ Created tags: v${MAJOR}-rc and v${MAJOR}.${MINOR}-rc"
            ;;

          pr)
            # Skip major/minor tag updates for PR versions
            echo "‚è≠Ô∏è  Skipping major/minor tag update for PR version: $VERSION"
            ;;
        esac

    - name: Push Changes and Tags
      if: inputs.git-push == 'true' && inputs.no-tags == 'false'
      shell: bash
      run: |
        echo "üöÄ Pushing all changes and tags to remote repository"

        # Push tags only
        git push --force origin --tags

        # Push all changes
        git push

        echo "‚úÖ Successfully pushed all changes and tags"
