name: "Auto Version"
description: "Automatically determine and tag semantic versions based on git tags"
author: "starburst997"

inputs:
  main-branch:
    description: "Name of the main/production branch"
    required: false
    default: "main"
  dev-branch:
    description: "Name of the development branch"
    required: false
    default: "dev"
  default-version:
    description: "Default version if no tags exist"
    required: false
    default: "1.0.0"
  git-user-name:
    description: "Git user name for tagging"
    required: false
    default: "github-actions[bot]"
  git-user-email:
    description: "Git user email for tagging"
    required: false
    default: "github-actions[bot]@users.noreply.github.com"
  update-major-minor:
    description: "Update major and minor version tags (e.g., v1, v1.2) to point to latest version"
    required: false
    default: "false"

outputs:
  version:
    description: "Calculated version (e.g., 1.2.3 or 1.2.3-dev)"
    value: ${{ steps.calculate.outputs.version }}
  tag:
    description: "Git tag (e.g., v1.2.3 or v1.2.3-dev)"
    value: ${{ steps.calculate.outputs.tag }}

runs:
  using: "composite"
  steps:
    - name: Calculate Version
      id: calculate
      shell: bash
      run: |
        set -eo pipefail  # Exit on error and pipe failures

        # Fetch all tags
        git fetch --tags || true

        MAIN_BRANCH="${{ inputs.main-branch }}"
        DEV_BRANCH="${{ inputs.dev-branch }}"
        DEFAULT_VERSION="${{ inputs.default-version }}"

        # Detect context: PR or push, and which branch
        IS_PR="${{ github.event_name == 'pull_request' }}"
        if [ "$IS_PR" == "true" ]; then
          BASE_REF="${{ github.base_ref }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
        else
          CURRENT_BRANCH="${{ github.ref_name }}"
        fi

        # Determine release type based on context
        if [ "$IS_PR" == "true" ]; then
          if [ "$BASE_REF" == "$MAIN_BRANCH" ]; then
            RELEASE_TYPE="rc"
          else
            RELEASE_TYPE="pr"
          fi
        else
          if [ "$CURRENT_BRANCH" == "$MAIN_BRANCH" ]; then
            RELEASE_TYPE="production"
          elif [ "$CURRENT_BRANCH" == "$DEV_BRANCH" ]; then
            RELEASE_TYPE="dev"
          else
            echo "‚ùå Unsupported branch: $CURRENT_BRANCH"
            exit 1
          fi
        fi

        echo "üîç Detected context: $RELEASE_TYPE"

        case "$RELEASE_TYPE" in
          production)
            # Get latest stable production tag
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)

            # Get latest dev or rc tag to determine production version
            LATEST_DEV_TAG=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)
            LATEST_RC_TAG=$(git tag -l "v*-rc.*" --sort=-version:refname | head -n1 || true)

            # Determine base version from dev/rc tags
            if [ -z "$LATEST_DEV_TAG" ] && [ -z "$LATEST_RC_TAG" ]; then
              # No dev/rc tags exist
              if [ -z "$LATEST_STABLE" ]; then
                # No tags at all, use default
                VERSION="$DEFAULT_VERSION"
              else
                # Only stable tags exist (direct main commits), increment patch (hotfix)
                STABLE_VER=${LATEST_STABLE#v}
                IFS='.' read -r MAJOR MINOR PATCH <<< "$STABLE_VER"
                PATCH=$((PATCH + 1))
                VERSION="${MAJOR}.${MINOR}.${PATCH}"
              fi
            else
              # Use latest dev or rc tag
              if [ -n "$LATEST_RC_TAG" ]; then
                LATEST_TAG=$LATEST_RC_TAG
              else
                LATEST_TAG=$LATEST_DEV_TAG
              fi

              # Strip 'v' and suffix to get base version
              BASE_VERSION=${LATEST_TAG#v}
              BASE_VERSION=${BASE_VERSION%%-*}

              # Check if this version already exists as stable
              if git rev-parse "v${BASE_VERSION}" >/dev/null 2>&1; then
                # Version already exists, increment minor (hotfix scenario)
                IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
                MINOR=$((MINOR + 1))
                VERSION="${MAJOR}.${MINOR}.0"
                echo "‚ö†Ô∏è  Version ${BASE_VERSION} already exists, using ${VERSION} (hotfix)"
              else
                # Version doesn't exist, use it
                VERSION="$BASE_VERSION"
              fi
            fi
            ;;

          dev)
            # Get latest stable (production) tag
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)

            # Get latest dev tag
            LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

            if [ -z "$LATEST_STABLE" ] && [ -z "$LATEST_DEV" ]; then
              # No tags exist, use default
              IFS='.' read -r MAJOR MINOR PATCH <<< "$DEFAULT_VERSION"
            elif [ -n "$LATEST_STABLE" ] && [ -z "$LATEST_DEV" ]; then
              # Production release exists but no dev yet, bump minor
              VERSION=${LATEST_STABLE#v}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
              MINOR=$((MINOR + 1))
              PATCH=0
            elif [ -n "$LATEST_STABLE" ]; then
              # Compare versions - if stable >= dev, we just released to prod
              STABLE_VER=${LATEST_STABLE#v}
              DEV_VER=${LATEST_DEV#v}
              DEV_VER=${DEV_VER%%-*}

              # Use sort -V to compare versions
              NEWER=$(printf "%s\n%s" "$STABLE_VER" "$DEV_VER" | sort -V -r | head -n1)

              if [ "$NEWER" == "$STABLE_VER" ] && [ "$STABLE_VER" != "$DEV_VER" ]; then
                # Production is newer, bump minor from stable
                IFS='.' read -r MAJOR MINOR PATCH <<< "$STABLE_VER"
                MINOR=$((MINOR + 1))
                PATCH=0
              else
                # Continue from dev, increment patch
                IFS='.' read -r MAJOR MINOR PATCH <<< "$DEV_VER"
                PATCH=$((PATCH + 1))
              fi
            else
              # Only dev tags exist, increment patch
              VERSION=${LATEST_DEV#v}
              VERSION=${VERSION%%-*}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
              PATCH=$((PATCH + 1))
            fi

            VERSION="${MAJOR}.${MINOR}.${PATCH}-dev"
            ;;

          rc)
            # Get latest dev or stable version tag to base our version on
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)
            LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

            # Use the most recent version as base
            if [ -n "$LATEST_DEV" ]; then
              LATEST_TAG=$LATEST_DEV
            elif [ -n "$LATEST_STABLE" ]; then
              LATEST_TAG=$LATEST_STABLE
            else
              LATEST_TAG=""
            fi

            if [ -z "$LATEST_TAG" ]; then
              MAJOR=1
              MINOR=0
              PATCH=0
            else
              VERSION_STR=${LATEST_TAG#v}
              VERSION_STR=${VERSION_STR%%-*}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_STR"
            fi

            BASE_VERSION="${MAJOR}.${MINOR}.${PATCH}"

            # Count existing rc tags for this base version
            RC_COUNT=$(git tag -l "v${BASE_VERSION}-rc.*" 2>/dev/null | wc -l | tr -d ' ')
            RC_NUM=$((RC_COUNT + 1))

            VERSION="${BASE_VERSION}-rc.${RC_NUM}"
            ;;

          pr)
            # Get latest dev or stable version tag to base our version on
            LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)
            LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

            # Use the most recent version as base
            if [ -n "$LATEST_DEV" ]; then
              LATEST_TAG=$LATEST_DEV
            elif [ -n "$LATEST_STABLE" ]; then
              LATEST_TAG=$LATEST_STABLE
            else
              LATEST_TAG=""
            fi

            if [ -z "$LATEST_TAG" ]; then
              MAJOR=1
              MINOR=0
              PATCH=0
            else
              VERSION_STR=${LATEST_TAG#v}
              VERSION_STR=${VERSION_STR%%-*}
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_STR"
            fi

            BASE_VERSION="${MAJOR}.${MINOR}.${PATCH}"

            # Count existing pr tags for this PR number and base version
            PR_COUNT=$(git tag -l "v${BASE_VERSION}-pr-${PR_NUMBER}.*" 2>/dev/null | wc -l | tr -d ' ')
            PR_NUM=$((PR_COUNT + 1))

            VERSION="${BASE_VERSION}-pr-${PR_NUMBER}.${PR_NUM}"
            ;;

          *)
            echo "‚ùå Invalid release-type: $RELEASE_TYPE"
            exit 1
            ;;
        esac

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Version: $VERSION"

    - name: Create and Push Tag
      shell: bash
      run: |
        git config user.name "${{ inputs.git-user-name }}"
        git config user.email "${{ inputs.git-user-email }}"
        git tag ${{ steps.calculate.outputs.tag }}
        git push origin ${{ steps.calculate.outputs.tag }}

    - name: Update Major/Minor Tags
      if: inputs.update-major-minor == 'true'
      shell: bash
      run: |
        VERSION=${{ steps.calculate.outputs.version }}

        # Detect release type from version suffix
        if [[ "$VERSION" == *"-dev"* ]]; then
          RELEASE_TYPE="dev"
        elif [[ "$VERSION" == *"-rc."* ]]; then
          RELEASE_TYPE="rc"
        elif [[ "$VERSION" == *"-pr-"* ]]; then
          RELEASE_TYPE="pr"
        else
          RELEASE_TYPE="production"
        fi

        # Strip any pre-release suffix (e.g., -dev, -rc.1, -pr-123.1)
        BASE_VERSION=${VERSION%%-*}

        # Extract major and minor versions
        IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

        case "$RELEASE_TYPE" in
          production)
            # Update major version tag (e.g., v1)
            git tag -f "v${MAJOR}"
            git push -f origin "v${MAJOR}"

            # Update minor version tag (e.g., v1.2)
            git tag -f "v${MAJOR}.${MINOR}"
            git push -f origin "v${MAJOR}.${MINOR}"

            echo "‚úÖ Updated tags: v${MAJOR} and v${MAJOR}.${MINOR}"
            ;;

          dev)
            # Update dev major version tag (e.g., v1-dev)
            git tag -f "v${MAJOR}-dev"
            git push -f origin "v${MAJOR}-dev"

            # Update dev minor version tag (e.g., v1.2-dev)
            git tag -f "v${MAJOR}.${MINOR}-dev"
            git push -f origin "v${MAJOR}.${MINOR}-dev"

            echo "‚úÖ Updated tags: v${MAJOR}-dev and v${MAJOR}.${MINOR}-dev"
            ;;

          rc)
            # Update rc major version tag (e.g., v1-rc)
            git tag -f "v${MAJOR}-rc"
            git push -f origin "v${MAJOR}-rc"

            # Update rc minor version tag (e.g., v1.2-rc)
            git tag -f "v${MAJOR}.${MINOR}-rc"
            git push -f origin "v${MAJOR}.${MINOR}-rc"

            echo "‚úÖ Updated tags: v${MAJOR}-rc and v${MAJOR}.${MINOR}-rc"
            ;;

          pr)
            # Skip major/minor tag updates for PR versions
            echo "‚è≠Ô∏è  Skipping major/minor tag update for PR version: $VERSION"
            ;;
        esac
