name: "Auto Version Tagger"
description: "Automatically determine and tag semantic versions based on git tags"
author: "starburst997"

branding:
  icon: "tag"
  color: "blue"

inputs:
  token:
    description: "GitHub token for API operations"
    required: false
    default: "${{ github.token }}"
  main-branch:
    description: "Name of the main/production branch"
    required: false
    default: "main"
  dev-branch:
    description: "Name of the development branch"
    required: false
    default: "dev"
  default-version:
    description: "Default version if no tags exist"
    required: false
    default: "1.0.0"
  git-config:
    description: "Set git config"
    required: false
    default: "true"
  git-user-name:
    description: "Git user name for tagging"
    required: false
    default: "github-actions[bot]"
  git-user-email:
    description: "Git user email for tagging"
    required: false
    default: "github-actions[bot]@users.noreply.github.com"
  update-major-minor:
    description: "Update major and minor version tags (e.g., v1, v1.2) to point to latest version"
    required: false
    default: "false"
  yearly:
    description: "Use year as major version (e.g., 2025.0.0) and auto-update on new year"
    required: false
    default: "false"
  git-push:
    description: "Push changes and tags to remote repository"
    required: false
    default: "true"
  no-tags:
    description: "Skip tag creation and pushing (only calculate version)"
    required: false
    default: "false"
  edit-file:
    description: "File to update with new version (e.g., action.yml). If empty, file editing is skipped"
    required: false
    default: ""
  edit-search-pattern:
    description: "Search pattern for version replacement (default uses repository name)"
    required: false
    default: "${{ github.repository }}:"
  edit-commit-message:
    description: "Commit message template for file edit (use {version} placeholder)"
    required: false
    default: "chore: update version to {version}"
  update-version-files:
    description: "Automatically update version in common version files (package.json, pyproject.toml, etc.) without committing"
    required: false
    default: "true"
  version-file-paths:
    description: "Additional paths to search for version files (space or newline separated, e.g., 'packages/app packages/lib' or multiline). Useful for monorepos"
    required: false
    default: ""
  patch-reset-value:
    description: "Value to reset PATCH to when incrementing MAJOR or MINOR"
    required: false
    default: "0"

outputs:
  version:
    description: "Calculated version (e.g., 1.2.3 or 1.2.3-dev)"
    value: ${{ steps.calculate.outputs.version }}
  tag:
    description: "Git tag (e.g., v1.2.3 or v1.2.3-dev)"
    value: ${{ steps.calculate.outputs.tag }}
  environment:
    description: "Environment type (production, dev, staging, or pr-###)"
    value: ${{ steps.calculate.outputs.environment }}
  suffix:
    description: "Version suffix (empty, dev, rc, or pr-###)"
    value: ${{ steps.calculate.outputs.suffix }}
  future-version:
    description: "The actual semantic version for transient environments (RC/PR) that would be used if not 0.0.0"
    value: ${{ steps.calculate.outputs.future-version }}
  stable-version:
    description: "Latest stable production version (without pre-release suffix)"
    value: ${{ steps.calculate.outputs.stable-version }}

runs:
  using: "composite"
  steps:
    - name: Configure Git
      if: inputs.git-config == 'true'
      shell: bash
      run: |
        # Only set git config if not already configured
        if [ -z "$(git config user.name)" ]; then
          git config user.name "${{ inputs.git-user-name }}"
          echo "✅ Set git user.name to ${{ inputs.git-user-name }}"
        else
          echo "ℹ️  Git user.name already set to: $(git config user.name)"
        fi

        if [ -z "$(git config user.email)" ]; then
          git config user.email "${{ inputs.git-user-email }}"
          echo "✅ Set git user.email to ${{ inputs.git-user-email }}"
        else
          echo "ℹ️  Git user.email already set to: $(git config user.email)"
        fi

    - name: Calculate Version
      id: calculate
      shell: bash
      run: |
        set -eo pipefail  # Exit on error and pipe failures

        # Fetch all tags
        git fetch --tags || true

        MAIN_BRANCH="${{ inputs.main-branch }}"
        DEV_BRANCH="${{ inputs.dev-branch }}"
        DEFAULT_VERSION="${{ inputs.default-version }}"
        YEARLY_MODE="${{ inputs.yearly }}"
        PATCH_RESET_VALUE="${{ inputs.patch-reset-value }}"

        # Get current year if yearly mode is enabled
        if [ "$YEARLY_MODE" == "true" ]; then
          CURRENT_YEAR=$(date +%Y)
          DEFAULT_VERSION="${CURRENT_YEAR}.0.0"
        fi

        # Calculate latest stable version once (used by multiple functions)
        LATEST_STABLE=$(git tag -l "v*" --sort=-version:refname | grep -v "dev\|rc\|pr" | head -n1 || true)

        # Helper function to handle yearly mode logic when incrementing minor
        # If yearly mode is enabled and current year > major, update major to current year
        handle_yearly_minor_increment() {
          local major=$1
          local minor=$2

          if [ "$YEARLY_MODE" == "true" ]; then
            if [ "$CURRENT_YEAR" -gt "$major" ]; then
              echo "$CURRENT_YEAR 0"
            else
              echo "$major $((minor + 1))"
            fi
          else
            echo "$major $((minor + 1))"
          fi
        }

        # Function to check commit messages for version bump commands
        check_commit_messages_for_bump() {
          local last_tag=$1
          local bump_type="patch"  # default

          # Get all commits since last tag (or all commits if no tag)
          local commits
          if [ -n "$last_tag" ]; then
            commits=$(git log "${last_tag}..HEAD" --format="%s %b" 2>/dev/null || true)
          else
            commits=$(git log --format="%s %b" 2>/dev/null || true)
          fi

          # Check for /major or /minor in commit messages
          if echo "$commits" | grep -q "/major"; then
            if [ "$YEARLY_MODE" == "true" ]; then
              echo "⚠️  /major command found but ignored in yearly mode (year is controlled automatically)"
              bump_type="minor"  # Treat as minor in yearly mode
            else
              bump_type="major"
            fi
          elif echo "$commits" | grep -q "/minor"; then
            bump_type="minor"
          fi

          echo "$bump_type"
        }

        # Function to calculate production version
        # Returns the version that would be used for a production release
        calculate_production_version() {
          # Check for version bump commands in commits
          local BUMP_TYPE=$(check_commit_messages_for_bump "$LATEST_STABLE")

          # Get latest dev tag to determine production version (NOT rc tags!)
          # RC tags are for PRs to main, not for regular dev->main merges
          local LATEST_DEV_TAG=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

          # Determine base version from dev tag
          if [ -z "$LATEST_DEV_TAG" ]; then
            # No dev tags exist (direct commits to main)
            if [ -z "$LATEST_STABLE" ]; then
              # No tags at all, use default
              echo "$DEFAULT_VERSION"
            else
              # Only stable tags exist (direct main commits)
              local STABLE_VER=${LATEST_STABLE#v}
              local MAJOR MINOR PATCH
              IFS='.' read -r MAJOR MINOR PATCH <<< "$STABLE_VER"

              # Apply bump type from commit messages
              case "$BUMP_TYPE" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=$PATCH_RESET_VALUE
                  ;;
                minor)
                  read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                  PATCH=$PATCH_RESET_VALUE
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac

              echo "${MAJOR}.${MINOR}.${PATCH}"
            fi
          else
            # Use latest dev tag (from dev->main merge)
            local LATEST_TAG=$LATEST_DEV_TAG

            # Strip 'v' and suffix to get base version
            local BASE_VERSION=${LATEST_TAG#v}
            BASE_VERSION=${BASE_VERSION%%-*}

            # Check if this version already exists as stable
            if git rev-parse "v${BASE_VERSION}" >/dev/null 2>&1; then
              # Version already exists, increment minor (hotfix scenario)
              local MAJOR MINOR PATCH
              IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
              read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
              echo "${MAJOR}.${MINOR}.${PATCH_RESET_VALUE}"
            else
              # Version doesn't exist, use it
              echo "$BASE_VERSION"
            fi
          fi
        }

        # Function to calculate dev version
        # Returns the version that would be used for a dev release
        calculate_dev_version() {
          # Get latest dev tag
          local LATEST_DEV=$(git tag -l "v*-dev" --sort=-version:refname | head -n1 || true)

          # Check for version bump commands in commits
          local BUMP_TYPE=$(check_commit_messages_for_bump "$LATEST_DEV")

          local MAJOR MINOR PATCH

          if [ -z "$LATEST_STABLE" ] && [ -z "$LATEST_DEV" ]; then
            # No tags exist, use default
            IFS='.' read -r MAJOR MINOR PATCH <<< "$DEFAULT_VERSION"
          elif [ -n "$LATEST_STABLE" ] && [ -z "$LATEST_DEV" ]; then
            # Production release exists but no dev yet, bump minor
            local VERSION=${LATEST_STABLE#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
            read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
            PATCH=$PATCH_RESET_VALUE
          elif [ -n "$LATEST_STABLE" ]; then
            # Compare versions - if stable >= dev, we just released to prod
            local STABLE_VER=${LATEST_STABLE#v}
            local DEV_VER=${LATEST_DEV#v}
            DEV_VER=${DEV_VER%%-*}

            # Use sort -V to compare versions
            local NEWER=$(printf "%s\n%s" "$STABLE_VER" "$DEV_VER" | sort -V -r | head -n1)

            if [ "$NEWER" == "$STABLE_VER" ]; then
              # Production is newer or equal, bump minor from stable
              IFS='.' read -r MAJOR MINOR PATCH <<< "$STABLE_VER"
              read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
              PATCH=$PATCH_RESET_VALUE
            else
              # Continue from dev
              IFS='.' read -r MAJOR MINOR PATCH <<< "$DEV_VER"

              # Apply bump type from commit messages
              case "$BUMP_TYPE" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=$PATCH_RESET_VALUE
                  ;;
                minor)
                  read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                  PATCH=$PATCH_RESET_VALUE
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
            fi
          else
            # Only dev tags exist
            local VERSION=${LATEST_DEV#v}
            VERSION=${VERSION%%-*}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

            # Apply bump type from commit messages
            case "$BUMP_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=$PATCH_RESET_VALUE
                ;;
              minor)
                read -r MAJOR MINOR <<< "$(handle_yearly_minor_increment $MAJOR $MINOR)"
                PATCH=$PATCH_RESET_VALUE
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
          fi

          echo "${MAJOR}.${MINOR}.${PATCH}-dev"
        }

        # Detect context: PR or push, and which branch
        IS_PR="${{ github.event_name == 'pull_request' }}"
        if [ "$IS_PR" == "true" ]; then
          BASE_REF="${{ github.base_ref }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
        else
          CURRENT_BRANCH="${{ github.ref_name }}"
        fi

        # Determine release type based on context
        if [ "$IS_PR" == "true" ]; then
          if [ "$BASE_REF" == "$MAIN_BRANCH" ]; then
            RELEASE_TYPE="rc"
          else
            RELEASE_TYPE="pr"
          fi
        else
          if [ "$CURRENT_BRANCH" == "$MAIN_BRANCH" ]; then
            RELEASE_TYPE="production"
          elif [ "$CURRENT_BRANCH" == "$DEV_BRANCH" ]; then
            RELEASE_TYPE="dev"
          else
            echo "❌ Unsupported branch: $CURRENT_BRANCH"
            exit 1
          fi
        fi

        echo "🔍 Detected context: $RELEASE_TYPE"

        # Calculate stable version output (strip 'v' prefix from LATEST_STABLE)
        if [ -z "$LATEST_STABLE" ]; then
          STABLE_VERSION="$DEFAULT_VERSION"
        else
          STABLE_VERSION="${LATEST_STABLE#v}"
        fi

        case "$RELEASE_TYPE" in
          production)
            VERSION=$(calculate_production_version)
            ;;

          dev)
            VERSION=$(calculate_dev_version)
            ;;

          rc)
            # Calculate the future version using production logic (what it would be when merged to main)
            FUTURE_VERSION=$(calculate_production_version)

            # Use 0.0.0 as base for transient RC versions
            BASE_VERSION="0.0.0"

            # Count existing rc tags for this base version
            RC_COUNT=$(git tag -l "v${BASE_VERSION}-rc.*" 2>/dev/null | wc -l | tr -d ' ')
            RC_NUM=$((RC_COUNT + 1))

            VERSION="${BASE_VERSION}-rc.${RC_NUM}"
            ;;

          pr)
            # Calculate the future version using dev logic (what it would be when merged to dev)
            FUTURE_VERSION=$(calculate_dev_version)

            # Use 0.0.0 as base for transient PR versions
            BASE_VERSION="0.0.0"

            # Count existing pr tags for this PR number and base version
            PR_COUNT=$(git tag -l "v${BASE_VERSION}-pr-${PR_NUMBER}.*" 2>/dev/null | wc -l | tr -d ' ')
            PR_NUM=$((PR_COUNT + 1))

            VERSION="${BASE_VERSION}-pr-${PR_NUMBER}.${PR_NUM}"
            ;;

          *)
            echo "❌ Invalid release-type: $RELEASE_TYPE"
            exit 1
            ;;
        esac

        # Determine environment and suffix outputs
        case "$RELEASE_TYPE" in
          production)
            ENVIRONMENT="production"
            SUFFIX=""
            FUTURE_VERSION="$VERSION"  # For production, future version is the same as version
            ;;
          dev)
            ENVIRONMENT="dev"
            SUFFIX="dev"
            FUTURE_VERSION="${VERSION%-dev}"  # For dev, future version is version without suffix
            ;;
          rc)
            ENVIRONMENT="staging"
            SUFFIX="rc"
            # FUTURE_VERSION already calculated above using calculate_production_version
            ;;
          pr)
            ENVIRONMENT="pr-${PR_NUMBER}"
            SUFFIX="pr-${PR_NUMBER}"
            # FUTURE_VERSION already calculated above using calculate_dev_version
            ;;
        esac

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$VERSION" >> $GITHUB_OUTPUT
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
        echo "future-version=$FUTURE_VERSION" >> $GITHUB_OUTPUT
        echo "stable-version=$STABLE_VERSION" >> $GITHUB_OUTPUT
        echo "📦 Version: $VERSION"
        echo "🌍 Environment: $ENVIRONMENT"
        echo "🏷️  Suffix: $SUFFIX"
        echo "🏁 Stable Version: $STABLE_VERSION"
        if [ "$RELEASE_TYPE" == "rc" ] || [ "$RELEASE_TYPE" == "pr" ]; then
          echo "🔮 Future Version: $FUTURE_VERSION"
        fi

    - name: Update File with New Version
      if: inputs.edit-file != ''
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        EDIT_FILE="${{ inputs.edit-file }}"
        SEARCH_PATTERN="${{ inputs.edit-search-pattern }}"
        VERSION="${{ steps.calculate.outputs.tag }}"
        COMMIT_MESSAGE="${{ inputs.edit-commit-message }}"

        echo "📝 Updating $EDIT_FILE with version $VERSION"

        # Convert repository name to lowercase for registry compatibility
        REPO_NAME=$(echo "$SEARCH_PATTERN" | tr '[:upper:]' '[:lower:]')

        # Replace version in file using sed
        sed -i "s|${REPO_NAME}[^\"]*|${REPO_NAME}${VERSION}|g" "$EDIT_FILE"

        # Check if file was actually changed
        if git diff --quiet "$EDIT_FILE"; then
          echo "ℹ️  No changes to $EDIT_FILE"
          exit 0
        fi

        # Replace {version} placeholder in commit message
        FINAL_MESSAGE="${COMMIT_MESSAGE/\{version\}/$VERSION}"

        # Get the current commit SHA
        BASE_SHA=$(git rev-parse HEAD)

        # Read the updated file content
        FILE_CONTENT=$(base64 -w 0 "$EDIT_FILE")

        # Get the file SHA (needed for update)
        FILE_SHA=$(gh api "repos/${{ github.repository }}/contents/$EDIT_FILE" --jq .sha)

        # Create commit via GitHub API
        gh api "repos/${{ github.repository }}/contents/$EDIT_FILE" \
          --method PUT \
          --field message="$FINAL_MESSAGE" \
          --field content="$FILE_CONTENT" \
          --field sha="$FILE_SHA" \
          --field branch="${{ github.ref_name }}"

        # Get latest changes
        git checkout "$EDIT_FILE"
        git pull

        echo "✅ Updated $EDIT_FILE via GitHub API with verified commit"

    - name: Update Version Files
      if: inputs.update-version-files == 'true'
      shell: bash
      run: |
        VERSION="${{ steps.calculate.outputs.version }}"
        ADDITIONAL_PATHS="${{ inputs.version-file-paths }}"

        echo "📝 Updating version files with version $VERSION"

        # Function to update version files in a given directory
        update_version_files_in_dir() {
          local dir="$1"
          local prefix="${2:+$2/}"  # Add trailing slash if prefix is not empty

          # JavaScript/TypeScript - package.json
          if [ -f "${dir}/package.json" ]; then
            echo "  Updating ${prefix}package.json"
            sed -i "s/\"version\": *\"[^\"]*\"/\"version\": \"$VERSION\"/g" "${dir}/package.json"
          fi

          # Python - pyproject.toml
          if [ -f "${dir}/pyproject.toml" ]; then
            echo "  Updating ${prefix}pyproject.toml"
            sed -i "s/^version *= *\"[^\"]*\"/version = \"$VERSION\"/g" "${dir}/pyproject.toml"
          fi

          # Python - setup.py
          if [ -f "${dir}/setup.py" ]; then
            echo "  Updating ${prefix}setup.py"
            sed -i "s/version=['\"][^'\"]*['\"]/version='$VERSION'/g" "${dir}/setup.py"
          fi

          # Rust - Cargo.toml
          if [ -f "${dir}/Cargo.toml" ]; then
            echo "  Updating ${prefix}Cargo.toml"
            sed -i "s/^version *= *\"[^\"]*\"/version = \"$VERSION\"/g" "${dir}/Cargo.toml"
          fi

          # Go - VERSION file (common pattern)
          if [ -f "${dir}/VERSION" ]; then
            echo "  Updating ${prefix}VERSION"
            echo "$VERSION" > "${dir}/VERSION"
          fi

          # Ruby - gemspec files
          if ls "${dir}"/*.gemspec 1> /dev/null 2>&1; then
            for file in "${dir}"/*.gemspec; do
              local filename=$(basename "$file")
              echo "  Updating ${prefix}${filename}"
              sed -i "s/\.version *= *['\"][^'\"]*['\"]/\.version = '$VERSION'/g" "$file"
            done
          fi

          # PHP - composer.json
          if [ -f "${dir}/composer.json" ]; then
            echo "  Updating ${prefix}composer.json"
            sed -i "s/\"version\": *\"[^\"]*\"/\"version\": \"$VERSION\"/g" "${dir}/composer.json"
          fi

          # .NET - *.csproj files
          if ls "${dir}"/*.csproj 1> /dev/null 2>&1; then
            for file in "${dir}"/*.csproj; do
              local filename=$(basename "$file")
              echo "  Updating ${prefix}${filename}"
              sed -i "s|<Version>[^<]*</Version>|<Version>$VERSION</Version>|g" "$file"
              sed -i "s|<AssemblyVersion>[^<]*</AssemblyVersion>|<AssemblyVersion>$VERSION</AssemblyVersion>|g" "$file"
              sed -i "s|<FileVersion>[^<]*</FileVersion>|<FileVersion>$VERSION</FileVersion>|g" "$file"
            done
          fi

          # Gradle - gradle.properties
          if [ -f "${dir}/gradle.properties" ]; then
            echo "  Updating ${prefix}gradle.properties"
            sed -i "s/^version *= *[^ ]*/version=$VERSION/g" "${dir}/gradle.properties"
          fi

          # Maven - pom.xml (first occurrence only, to avoid changing dependency versions)
          if [ -f "${dir}/pom.xml" ]; then
            echo "  Updating ${prefix}pom.xml"
            sed -i "0,/<version>[^<]*<\/version>/s|<version>[^<]*</version>|<version>$VERSION</version>|" "${dir}/pom.xml"
          fi
        }

        # Update version files in root directory
        update_version_files_in_dir "." ""

        # Process additional paths if specified
        if [ -n "$ADDITIONAL_PATHS" ]; then
          # Convert multiline input to single line with spaces
          PATHS=$(echo "$ADDITIONAL_PATHS" | tr '\n' ' ')

          # Iterate over each path
          for path in $PATHS; do
            # Skip empty paths
            if [ -z "$path" ]; then
              continue
            fi

            # Check if directory exists
            if [ -d "$path" ]; then
              echo ""
              echo "📂 Processing additional path: $path"
              update_version_files_in_dir "$path" "$path"
            else
              echo "⚠️  Warning: Path '$path' does not exist, skipping"
            fi
          done
        fi

        echo ""
        echo "✅ Version files updated (not committed)"

    - name: Create Tags
      if: inputs.no-tags == 'false'
      shell: bash
      run: |
        git tag ${{ steps.calculate.outputs.tag }}
        echo "✅ Created tag ${{ steps.calculate.outputs.tag }}"

    - name: Update Major/Minor Tags
      if: inputs.update-major-minor == 'true' && inputs.no-tags == 'false'
      shell: bash
      run: |
        VERSION=${{ steps.calculate.outputs.version }}

        # Detect release type from version suffix
        if [[ "$VERSION" == *"-dev"* ]]; then
          RELEASE_TYPE="dev"
        elif [[ "$VERSION" == *"-rc."* ]]; then
          RELEASE_TYPE="rc"
        elif [[ "$VERSION" == *"-pr-"* ]]; then
          RELEASE_TYPE="pr"
        else
          RELEASE_TYPE="production"
        fi

        # Strip any pre-release suffix (e.g., -dev, -rc.1, -pr-123.1)
        BASE_VERSION=${VERSION%%-*}

        # Extract major and minor versions
        IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

        case "$RELEASE_TYPE" in
          production)
            # Update major version tag (e.g., v1)
            git tag -f "v${MAJOR}"

            # Update minor version tag (e.g., v1.2)
            git tag -f "v${MAJOR}.${MINOR}"

            echo "✅ Created tags: v${MAJOR} and v${MAJOR}.${MINOR}"
            ;;

          dev)
            # Update dev major version tag (e.g., v1-dev)
            git tag -f "v${MAJOR}-dev"

            # Update dev minor version tag (e.g., v1.2-dev)
            git tag -f "v${MAJOR}.${MINOR}-dev"

            echo "✅ Created tags: v${MAJOR}-dev and v${MAJOR}.${MINOR}-dev"
            ;;

          rc)
            # Update rc major version tag (e.g., v1-rc)
            git tag -f "v${MAJOR}-rc"

            # Update rc minor version tag (e.g., v1.2-rc)
            git tag -f "v${MAJOR}.${MINOR}-rc"

            echo "✅ Created tags: v${MAJOR}-rc and v${MAJOR}.${MINOR}-rc"
            ;;

          pr)
            # Skip major/minor tag updates for PR versions
            echo "⏭️  Skipping major/minor tag update for PR version: $VERSION"
            ;;
        esac

    - name: Push Changes and Tags
      if: inputs.git-push == 'true' && inputs.no-tags == 'false'
      shell: bash
      run: |
        echo "🚀 Pushing all changes and tags to remote repository"

        # Push tags only
        git push --force origin --tags

        # Push all changes (ignore detached HEAD state in PRs)
        git push || echo "⚠️  Skipping commit push (detached HEAD state - common in PR context)"

        echo "✅ Successfully pushed tags"
